-- MySQL Workbench Forward Engineering

SET @OLD_UNIQUE_CHECKS=@@UNIQUE_CHECKS, UNIQUE_CHECKS=0;
SET @OLD_FOREIGN_KEY_CHECKS=@@FOREIGN_KEY_CHECKS, FOREIGN_KEY_CHECKS=0;
SET @OLD_SQL_MODE=@@SQL_MODE, SQL_MODE='TRADITIONAL,ALLOW_INVALID_DATES';

-- -----------------------------------------------------
-- Schema lexis_nexis
-- -----------------------------------------------------

-- -----------------------------------------------------
-- Schema lexis_nexis
-- -----------------------------------------------------
CREATE SCHEMA IF NOT EXISTS `lexis_nexis` DEFAULT CHARACTER SET utf8 ;
USE `lexis_nexis` ;
USE `lexis_nexis` ;

-- -----------------------------------------------------
-- procedure p_add_log
-- -----------------------------------------------------

USE `lexis_nexis`;
DROP procedure IF EXISTS `lexis_nexis`.`p_add_log`;

DELIMITER $$
USE `lexis_nexis`$$
CREATE PROCEDURE `p_add_log`(LOG_CD INT, LOG_MSG VARCHAR(5000), LOG_USR VARCHAR(255))
BEGIN
	INSERT INTO APPL_LOG (APPL_LOG_CD, APPL_LOG_DESC, APPL_LOG_USR_NME, APPL_LOG_DT)
    VALUES (LOG_CD, LOG_MSG, LOG_USR, NOW());
END$$

DELIMITER ;

-- -----------------------------------------------------
-- procedure p_add_usr_srch
-- -----------------------------------------------------

USE `lexis_nexis`;
DROP procedure IF EXISTS `lexis_nexis`.`p_add_usr_srch`;

DELIMITER $$
USE `lexis_nexis`$$
CREATE PROCEDURE `p_add_usr_srch`(SRCH_NME VARCHAR(5000), SRCH_USR VARCHAR(255), SRCH_QRY TEXT,
								SRCH_SRC TEXT, SRCH_TO_DT DATETIME, SRCH_FROM_DT DATETIME, SRCH_MTHD VARCHAR(255))
BEGIN
	DECLARE STAT_CD INT DEFAULT 1;
	DECLARE POS INT DEFAULT 1;
    
	SELECT APPL_LKUP_CD INTO STAT_CD FROM APPL_LKUP WHERE APPL_LKUP_DESC = 'Pending';
    
    # Determine the position in the queue
    SELECT COALESCE(MAX(APPL_USR_SRCH_QUEUE_POS),0)+ 1 INTO POS FROM APPL_USR_SRCH_STAT
    WHERE APPL_USR_SRCH_REC_TRMN_DT IS NULL
	AND APPL_USR_SRCH_STAT_CD IN 
	(SELECT APPL_LKUP_CD FROM APPL_LKUP WHERE APPL_LKUP_DESC IN ('Pending','Processing'));
    
	INSERT INTO APPL_USR_SRCH_STAT (APPL_USR_SRCH_SVD_NME, APPL_USR_SRCH_USR_NME,
		APPL_USR_SRCH_STAT_CD, APPL_USR_SRCH_REC_EFF_DT, APPL_USR_SRCH_REC_TRMN_DT,
		APPL_USR_SRCH_RSLT_LOC, APPL_USR_SRCH_PCT_CMPLT, APPL_USR_SRCH_QRY, APPL_USR_SRCH_SRC, 
        APPL_USR_SRCH_ST_DT, APPL_USR_SRCH_END_DT,
        APPL_USR_SRCH_CURR_ST_DT, APPL_USR_SRCH_CURR_END_DT, APPL_USR_SRCH_ST_INDX, 
        APPL_USR_SRCH_MTHD, APPL_USR_SRCH_RETRY_CNT, APPL_USR_SRCH_CREATE_DT, APPL_USR_SRCH_QUEUE_POS)
	VALUES (SRCH_NME, SRCH_USR, STAT_CD, NOW(), NULL, NULL, 0.0, SRCH_QRY, SRCH_SRC, SRCH_FROM_DT, 
    SRCH_TO_DT, SRCH_FROM_DT, SRCH_TO_DT, 1, SRCH_MTHD,0, NOW(), POS);
END$$

DELIMITER ;

-- -----------------------------------------------------
-- procedure p_del_usr_records
-- -----------------------------------------------------

USE `lexis_nexis`;
DROP procedure IF EXISTS `lexis_nexis`.`p_del_usr_records`;

DELIMITER $$
USE `lexis_nexis`$$
CREATE  PROCEDURE `p_del_usr_records`()
BEGIN
	DECLARE NO_MTHS INT DEFAULT 3;
    
    SELECT APPL_PARAM_VAL INTO NO_MTHS FROM APPL_PARAM WHERE APPL_PARAM_NME = 'MTHS_TO_DEL';
    
    CREATE TEMPORARY TABLE IF NOT EXISTS tmp_tbl AS (
	SELECT DISTINCT APPL_USR_SRCH_RSLT_LOC FROM APPL_USR_SRCH_STAT
    WHERE ADDDATE(APPL_USR_SRCH_REC_EFF_DT,INTERVAL NO_MTHS MONTH) < NOW()
    AND APPL_USR_SRCH_RSLT_LOC IS NOT NULL);
    
    UPDATE APPL_USR_SRCH_STAT SET APPL_USR_SRCH_USR_NME = 'DELETED', APPL_USR_SRCH_REC_TRMN_DT = NOW() WHERE ADDDATE(APPL_USR_SRCH_REC_EFF_DT,INTERVAL NO_MTHS MONTH) < NOW();
    UPDATE APPL_LOG SET APPL_LOG_USR_NME = 'DELETED' WHERE ADDDATE(APPL_LOG_DT, INTERVAL NO_MTHS MONTH) < NOW();
    
    SELECT APPL_USR_SRCH_RSLT_LOC AS RSLT_LOC FROM tmp_tbl;
    
	DROP TEMPORARY TABLE IF EXISTS tmp_tbl;

END$$

DELIMITER ;

-- -----------------------------------------------------
-- procedure p_del_usr_srch
-- -----------------------------------------------------

USE `lexis_nexis`;
DROP procedure IF EXISTS `lexis_nexis`.`p_del_usr_srch`;

DELIMITER $$
USE `lexis_nexis`$$
CREATE PROCEDURE `p_del_usr_srch`(SRCH_NME VARCHAR(5000))
BEGIN  
	DECLARE POS INT;
    
    SELECT APPL_USR_SRCH_QUEUE_POS INTO POS FROM APPL_USR_SRCH_STAT
    WHERE APPL_USR_SRCH_SVD_NME = SRCH_NME AND APPL_USR_SRCH_REC_TRMN_DT IS NULL;
    
	# perform update first so trigger will move record to history table
	UPDATE APPL_USR_SRCH_STAT SET APPL_USR_SRCH_REC_TRMN_DT = NOW()
    WHERE APPL_USR_SRCH_SVD_NME = SRCH_NME AND APPL_USR_SRCH_REC_TRMN_DT IS NULL;
    
    DELETE FROM APPL_USR_SRCH_STAT WHERE APPL_USR_SRCH_SVD_NME = SRCH_NME AND APPL_USR_SRCH_REC_TRMN_DT IS NOT NULL;
    
    # update the queue positions
    UPDATE APPL_USR_SRCH_STAT
    SET APPL_USR_SRCH_QUEUE_POS = APPL_USR_SRCH_QUEUE_POS - 1
    WHERE APPL_USR_SRCH_QUEUE_POS > POS 
    AND APPL_USR_SRCH_REC_TRMN_DT IS NULL
	AND APPL_USR_SRCH_STAT_CD IN 
	(SELECT APPL_LKUP_CD FROM APPL_LKUP WHERE APPL_LKUP_DESC IN ('Pending','Processing'));
END$$

DELIMITER ;

-- -----------------------------------------------------
-- procedure p_get_appl_lkup
-- -----------------------------------------------------

USE `lexis_nexis`;
DROP procedure IF EXISTS `lexis_nexis`.`p_get_appl_lkup`;

DELIMITER $$
USE `lexis_nexis`$$
CREATE PROCEDURE `p_get_appl_lkup`()
BEGIN	   
	SELECT APPL_LKUP_CD, APPL_LKUP_CATG_NME, APPL_LKUP_DESC
	FROM APPL_LKUP;
END$$

DELIMITER ;

-- -----------------------------------------------------
-- procedure p_get_appl_param
-- -----------------------------------------------------

USE `lexis_nexis`;
DROP procedure IF EXISTS `lexis_nexis`.`p_get_appl_param`;

DELIMITER $$
USE `lexis_nexis`$$
CREATE  PROCEDURE `p_get_appl_param`()
BEGIN	   
	SELECT APPL_PARAM_NME, APPL_PARAM_VAL, APPL_PARAM_DESC
	FROM APPL_PARAM;
END$$

DELIMITER ;

-- -----------------------------------------------------
-- procedure p_get_appl_srch_stat
-- -----------------------------------------------------

USE `lexis_nexis`;
DROP procedure IF EXISTS `lexis_nexis`.`p_get_appl_srch_stat`;

DELIMITER $$
USE `lexis_nexis`$$
CREATE PROCEDURE `p_get_appl_srch_stat`(OUT REMAINING INT, OUT CURRENT INT)
BEGIN	  
	DECLARE EFF_DT DATETIME;
	DECLARE CNT INT;
	DECLARE MAX_CNT INT;

	SELECT APPL_PARAM_VAL INTO MAX_CNT FROM APPL_PARAM WHERE APPL_PARAM_NME = 'SRCH_PR_HR';
 
	SELECT APPL_SRCH_STAT_REC_EFF_DT,APPL_SRCH_STAT_VAL INTO EFF_DT, CNT
    FROM APPL_SRCH_STAT WHERE APPL_SRCH_STAT_REC_TRMN_DT IS NULL;
    
    IF HOUR(EFF_DT) != HOUR(NOW()) THEN SET REMAINING  = MAX_CNT; SET CURRENT = 0;
    ELSE SET REMAINING = MAX_CNT - CNT; SET CURRENT = CNT;
    END IF;
END$$

DELIMITER ;

-- -----------------------------------------------------
-- procedure p_get_nex_run_window
-- -----------------------------------------------------

USE `lexis_nexis`;
DROP procedure IF EXISTS `lexis_nexis`.`p_get_nex_run_window`;

DELIMITER $$
USE `lexis_nexis`$$
CREATE PROCEDURE `p_get_nex_run_window`(OUT RUN_WINDOW DATETIME)
BEGIN
	DECLARE WK_DY INT;
    DECLARE RUN_HR VARCHAR(255);
    
    SELECT WEEKDAY(NOW()) INTO WK_DY;
    
    IF WK_DY IN (6,7) 
    THEN
		SELECT APPL_PARAM_VAL INTO RUN_HR FROM APPL_PARAM WHERE APPL_PARAM_NME = 'WEEKEND_START';
	ELSE
		SELECT APPL_PARAM_VAL INTO RUN_HR FROM APPL_PARAM WHERE APPL_PARAM_NME = 'WEEKDAY_START';
	END IF;
    
    SELECT  STR_TO_DATE(concat(MONTH(NOW()),'/',DAY(NOW()),'/',YEAR(NOW()),' ',RUN_HR), '%m/%d/%Y %H:%i') INTO RUN_WINDOW;

END$$

DELIMITER ;

-- -----------------------------------------------------
-- procedure p_get_run_stat
-- -----------------------------------------------------

USE `lexis_nexis`;
DROP procedure IF EXISTS `lexis_nexis`.`p_get_run_stat`;

DELIMITER $$
USE `lexis_nexis`$$
CREATE PROCEDURE `p_get_run_stat`(OUT RUN_STAT INT)
BEGIN	  
	SELECT APPL_RUN_STAT_VAL INTO RUN_STAT
    FROM APPL_RUN_STAT WHERE APPL_RUN_STAT_REC_TRMN_DT IS NULL;
    
END$$

DELIMITER ;

-- -----------------------------------------------------
-- procedure p_get_srch_queue
-- -----------------------------------------------------

USE `lexis_nexis`;
DROP procedure IF EXISTS `lexis_nexis`.`p_get_srch_queue`;

DELIMITER $$
USE `lexis_nexis`$$
CREATE PROCEDURE `p_get_srch_queue`()
BEGIN
	DECLARE CNT INT;
	# rotate queue order
	SELECT COUNT(*) INTO CNT FROM APPL_USR_SRCH_STAT S
		  INNER JOIN APPL_LKUP L ON S.APPL_USR_SRCH_STAT_CD = L.APPL_LKUP_CD
		  WHERE S.APPL_USR_SRCH_REC_TRMN_DT IS NULL
		  AND L.APPL_LKUP_DESC IN ('Pending','Processing')
          AND NOT COALESCE(S.ON_HOLD, FALSE);
          
	UPDATE APPL_USR_SRCH_STAT SET APPL_USR_SRCH_QUEUE_POS = 
			(CASE WHEN APPL_USR_SRCH_QUEUE_POS <> CNT THEN APPL_USR_SRCH_QUEUE_POS ELSE 0 END) + 1
    WHERE APPL_USR_SRCH_REC_TRMN_DT IS NULL
		AND APPL_USR_SRCH_STAT_CD IN 
			(SELECT APPL_LKUP_CD FROM APPL_LKUP WHERE APPL_LKUP_DESC IN ('Pending','Processing'))
            AND APPL_USR_SRCH_QUEUE_POS != 
			(CASE WHEN APPL_USR_SRCH_QUEUE_POS <> CNT THEN APPL_USR_SRCH_QUEUE_POS ELSE 0 END) + 1
            AND NOT COALESCE(ON_HOLD, FALSE);


  SELECT S.APPL_USR_SRCH_STAT_REC_ID, S.APPL_USR_SRCH_SVD_NME, 
		S.APPL_USR_SRCH_STAT_CD, S.APPL_USR_SRCH_RSLT_LOC,	 S.APPL_USR_SRCH_QRY, 
        S.APPL_USR_SRCH_SRC, S.APPL_USR_SRCH_ST_DT, S.APPL_USR_SRCH_END_DT, 
        S.APPL_USR_SRCH_PCT_CMPLT, S.APPL_USR_SRCH_USR_NME, S.APPL_USR_SRCH_ST_INDX, 
        S.APPL_USR_SRCH_NUM_RSLTS, S.APPL_USR_SRCH_MTHD, S.APPL_USR_SRCH_CURR_ST_DT, 
        S.APPL_USR_SRCH_CURR_END_DT, S.APPL_USR_SRCH_RETRY_CNT, S.APPL_USR_SRCH_LN_ID, S.APPL_USR_SRCH_RNG_RSLTS,
        S.APPL_USR_SRCH_QUEUE_POS, S.EMAILED
  FROM APPL_USR_SRCH_STAT S
  INNER JOIN APPL_LKUP L ON S.APPL_USR_SRCH_STAT_CD = L.APPL_LKUP_CD
  WHERE S.APPL_USR_SRCH_REC_TRMN_DT IS NULL
  AND L.APPL_LKUP_DESC IN ('Pending','Processing')
  AND NOT COALESCE(S.ON_HOLD, FALSE)
  ORDER BY S.APPL_USR_SRCH_QUEUE_POS ASC;
 END$$

DELIMITER ;

-- -----------------------------------------------------
-- procedure p_get_srch_src
-- -----------------------------------------------------

USE `lexis_nexis`;
DROP procedure IF EXISTS `lexis_nexis`.`p_get_srch_src`;

DELIMITER $$
USE `lexis_nexis`$$
CREATE PROCEDURE `p_get_srch_src`()
BEGIN	   
	SELECT APPL_SRCH_SRC_ID, APPL_SRCH_SRC_NME, APPL_SRCH_SRC_FLDR
	FROM APPL_SRCH_SRC WHERE APPL_SRCH_SRC_REC_TRMN_DT IS NULL;
END$$

DELIMITER ;

-- -----------------------------------------------------
-- procedure p_get_usr_srch
-- -----------------------------------------------------

USE `lexis_nexis`;
DROP procedure IF EXISTS `lexis_nexis`.`p_get_usr_srch`;

DELIMITER $$
USE `lexis_nexis`$$
CREATE PROCEDURE `p_get_usr_srch`(USR_NME VARCHAR(255))
BEGIN
 SELECT S.APPL_USR_SRCH_STAT_REC_ID, S.APPL_USR_SRCH_SVD_NME, 
 DATE_FORMAT(S.APPL_USR_SRCH_CREATE_DT, '%b %d %Y %h:%i %p') AS APPL_USR_SRCH_REC_EFF_DT, 
	CASE WHEN L.APPL_LKUP_DESC = 'INVALID' THEN CONCAT('Invalid Search! ',S.APPL_USR_SRCH_ERR_MSG) 
		WHEN L.APPL_LKUP_DESC = 'Complete' AND S.APPL_USR_SRCH_NUM_RSLTS = 0 THEN 'No Results!'
		ELSE L.APPL_LKUP_DESC END AS APPL_LKUP_DESC,     
    S.APPL_USR_SRCH_RSLT_LOC,
    CASE WHEN L.APPL_LKUP_DESC = 'Complete' AND S.APPL_USR_SRCH_NUM_RSLTS = 0 THEN 'Cancel' 
		WHEN L.APPL_LKUP_DESC = 'Complete' AND S.APPL_USR_SRCH_READY_TO_DWNLD = TRUE THEN 'Download'
        WHEN L.APPL_LKUP_DESC = 'Complete' AND S.APPL_USR_SRCH_READY_TO_DWNLD = FALSE THEN ''
		WHEN L.APPL_LKUP_DESC = 'Invalid'  THEN 'Cancel'
        WHEN L.APPL_LKUP_DESC = 'Pending'  THEN 'Cancel'
        ELSE ''
	END AS APPL_USR_SRCH_ACTN,
	CONVERT(TRUNCATE((S.APPL_USR_SRCH_PCT_CMPLT * 100),0),CHAR) as PCT_CMPLT,
	S.APPL_USR_SRCH_NUM_RSLTS,
	CASE WHEN L.APPL_LKUP_DESC = 'Complete' OR L.APPL_LKUP_DESC = 'Invalid' THEN 'N/A' 
		WHEN S.ON_HOLD = TRUE THEN 'On Hold'
		ELSE S.APPL_USR_SRCH_QUEUE_POS END AS QUEUE_POS,
	S.APPL_USR_SRCH_QRY
  FROM APPL_USR_SRCH_STAT S
  INNER JOIN APPL_LKUP L ON (S.APPL_USR_SRCH_STAT_CD = L.APPL_LKUP_CD AND L.APPL_LKUP_CATG_NME = 'SRCH_STAT')
  WHERE S.APPL_USR_SRCH_REC_TRMN_DT IS NULL
  AND S.APPL_USR_SRCH_USR_NME = USR_NME
  ORDER BY S.APPL_USR_SRCH_CREATE_DT DESC;
 END$$

DELIMITER ;

-- -----------------------------------------------------
-- procedure p_incmnt_appl_srch_stat
-- -----------------------------------------------------

USE `lexis_nexis`;
DROP procedure IF EXISTS `lexis_nexis`.`p_incmnt_appl_srch_stat`;

DELIMITER $$
USE `lexis_nexis`$$
CREATE PROCEDURE `p_incmnt_appl_srch_stat`()
BEGIN
	DECLARE EFF_DT DATETIME;
	DECLARE CNT INT;
    
	START TRANSACTION;
        
		SELECT APPL_SRCH_STAT_REC_EFF_DT,APPL_SRCH_STAT_VAL INTO EFF_DT, CNT
		FROM APPL_SRCH_STAT WHERE APPL_SRCH_STAT_REC_TRMN_DT IS NULL;
        
		IF HOUR(EFF_DT) != HOUR(NOW())
		THEN
			UPDATE APPL_SRCH_STAT SET APPL_SRCH_STAT_REC_TRMN_DT = NOW()
			WHERE APPL_SRCH_STAT_REC_TRMN_DT IS NULL;
            
            INSERT INTO APPL_SRCH_STAT (APPL_SRCH_STAT_VAL, APPL_SRCH_STAT_REC_EFF_DT,  APPL_SRCH_STAT_REC_LAST_UPD_DT, APPL_SRCH_STAT_REC_TRMN_DT)
            VALUES (1, NOW(), NOW(), NULL);
		ELSE	
			UPDATE APPL_SRCH_STAT SET APPL_SRCH_STAT_REC_LAST_UPD_DT = NOW(), APPL_SRCH_STAT_VAL = CNT + 1
			WHERE APPL_SRCH_STAT_REC_TRMN_DT IS NULL;
		END IF;
    
    COMMIT;
END$$

DELIMITER ;

-- -----------------------------------------------------
-- procedure p_set_run_stat
-- -----------------------------------------------------

USE `lexis_nexis`;
DROP procedure IF EXISTS `lexis_nexis`.`p_set_run_stat`;

DELIMITER $$
USE `lexis_nexis`$$
CREATE PROCEDURE `p_set_run_stat`(RUN_STAT INT)
BEGIN  
	START TRANSACTION;
		
		UPDATE APPL_RUN_STAT SET APPL_RUN_STAT_REC_TRMN_DT = NOW()
		WHERE  APPL_RUN_STAT_REC_TRMN_DT IS NULL;
		
		INSERT INTO APPL_RUN_STAT (APPL_RUN_STAT_VAL, APPL_RUN_STAT_REC_EFF_DT, APPL_RUN_STAT_REC_TRMN_DT) 
        VALUES (RUN_STAT, NOW(), NULL);
    
    COMMIT;
END$$

DELIMITER ;

-- -----------------------------------------------------
-- procedure p_upd_usr_srch
-- -----------------------------------------------------

USE `lexis_nexis`;
DROP procedure IF EXISTS `lexis_nexis`.`p_upd_usr_srch`;

DELIMITER $$
USE `lexis_nexis`$$
CREATE PROCEDURE `p_upd_usr_srch`(SRCH_NME VARCHAR(5000), STAT_CD INT, RSLT_LOC VARCHAR(1000), 
								PCT_CMPLT DECIMAL(5,2), ST_INDX INT, NUM_RSLTS INT,
								CURR_ST DATETIME, CURR_END DATETIME, ERR_MSG VARCHAR(5000),RETRY_CNT INT, 
                                LN_ID TEXT, RNG_RSLTS INT, FILE_SIZE LONG, FILE_CHECK DATETIME, READY_FLAG BOOL, QUEUE_POS INT, EMAILED BOOL)
BEGIN		
	UPDATE APPL_USR_SRCH_STAT 
	SET APPL_USR_SRCH_SVD_NME = SRCH_NME, 
	APPL_USR_SRCH_STAT_CD = STAT_CD, 
	APPL_USR_SRCH_REC_EFF_DT = NOW(), 
	APPL_USR_SRCH_REC_TRMN_DT = NULL, 
	APPL_USR_SRCH_RSLT_LOC = RSLT_LOC, 
	APPL_USR_SRCH_PCT_CMPLT =PCT_CMPLT,
	APPL_USR_SRCH_ST_INDX = ST_INDX, 
	APPL_USR_SRCH_NUM_RSLTS = NUM_RSLTS, 
	APPL_USR_SRCH_CURR_ST_DT = CURR_ST, 
	APPL_USR_SRCH_CURR_END_DT = CURR_END, 
	APPL_USR_SRCH_ERR_MSG = ERR_MSG, 
	APPL_USR_SRCH_RETRY_CNT = RETRY_CNT,
    APPL_USR_SRCH_LN_ID = LN_ID,
    APPL_USR_SRCH_RNG_RSLTS = RNG_RSLTS,
    APPL_USR_SRCH_FILE_SIZE = FILE_SIZE,
	APPL_USR_SRCH_FILE_SIZE_CHECK_DT = FILE_CHECK,
	APPL_USR_SRCH_READY_TO_DWNLD = READY_FLAG,
    APPL_USR_SRCH_QUEUE_POS = QUEUE_POS,
    EMAILED = EMAILED
	WHERE APPL_USR_SRCH_SVD_NME = SRCH_NME AND APPL_USR_SRCH_REC_TRMN_DT IS NULL;

END$$

DELIMITER ;

-- -----------------------------------------------------
-- procedure p_get_zip_queue
-- -----------------------------------------------------

USE `lexis_nexis`;
DROP procedure IF EXISTS `lexis_nexis`.`p_get_zip_queue`;

DELIMITER $$
USE `lexis_nexis`$$
CREATE PROCEDURE `p_get_zip_queue`()
BEGIN
  SELECT S.APPL_USR_SRCH_STAT_REC_ID, S.APPL_USR_SRCH_SVD_NME, 
		S.APPL_USR_SRCH_STAT_CD, S.APPL_USR_SRCH_RSLT_LOC,	 S.APPL_USR_SRCH_QRY, 
        S.APPL_USR_SRCH_SRC, S.APPL_USR_SRCH_ST_DT, S.APPL_USR_SRCH_END_DT, 
        S.APPL_USR_SRCH_PCT_CMPLT, S.APPL_USR_SRCH_USR_NME, S.APPL_USR_SRCH_ST_INDX, 
        S.APPL_USR_SRCH_NUM_RSLTS, S.APPL_USR_SRCH_MTHD, S.APPL_USR_SRCH_CURR_ST_DT, 
        S.APPL_USR_SRCH_CURR_END_DT, S.APPL_USR_SRCH_RETRY_CNT, S.APPL_USR_SRCH_LN_ID, S.APPL_USR_SRCH_RNG_RSLTS,
        S.APPL_USR_SRCH_FILE_SIZE, S.APPL_USR_SRCH_FILE_SIZE_CHECK_DT, S.APPL_USR_SRCH_READY_TO_DWNLD, S.EMAILED
  FROM APPL_USR_SRCH_STAT S
  WHERE S.APPL_USR_SRCH_REC_TRMN_DT IS NULL
  AND S.APPL_USR_SRCH_RSLT_LOC IS NOT NULL AND S.APPL_USR_SRCH_RSLT_LOC != ""
  AND (S.APPL_USR_SRCH_READY_TO_DWNLD = FALSE OR S.APPL_USR_SRCH_READY_TO_DWNLD IS NULL)
  ORDER BY S.APPL_USR_SRCH_QUEUE_POS ASC;
 END$$

DELIMITER ;
USE `lexis_nexis`;

DELIMITER $$

USE `lexis_nexis`$$
DROP TRIGGER IF EXISTS `lexis_nexis`.`USR_SRCH_AFTER_UPDATE` $$
USE `lexis_nexis`$$
CREATE
TRIGGER `lexis_nexis`.`USR_SRCH_AFTER_UPDATE`
AFTER UPDATE ON `lexis_nexis`.`APPL_USR_SRCH_STAT`
FOR EACH ROW
BEGIN
INSERT INTO APPL_USR_SRCH_STAT_HIST (APPL_USR_SRCH_SVD_NME, APPL_USR_SRCH_USR_NME,
			APPL_USR_SRCH_STAT_CD, APPL_USR_SRCH_REC_EFF_DT, APPL_USR_SRCH_REC_TRMN_DT, APPL_USR_SRCH_RSLT_LOC, APPL_USR_SRCH_PCT_CMPLT, APPL_USR_SRCH_RNG_RSLTS, 
            APPL_USR_SRCH_QRY, APPL_USR_SRCH_SRC, APPL_USR_SRCH_ST_DT, APPL_USR_SRCH_END_DT, APPL_USR_SRCH_ST_INDX, APPL_USR_SRCH_NUM_RSLTS, APPL_USR_SRCH_MTHD, APPL_USR_SRCH_LN_ID,
            APPL_USR_SRCH_CURR_ST_DT, APPL_USR_SRCH_CURR_END_DT, APPL_USR_SRCH_ERR_MSG, APPL_USR_SRCH_RETRY_CNT, APPL_USR_SRCH_CREATE_DT, APPL_USR_SRCH_QUEUE_POS,
            APPL_USR_SRCH_FILE_SIZE, APPL_USR_SRCH_FILE_SIZE_CHECK_DT, APPL_USR_SRCH_READY_TO_DWNLD, ON_HOLD, EMAILED)
	VALUES (old.APPL_USR_SRCH_SVD_NME, old.APPL_USR_SRCH_USR_NME,
			old.APPL_USR_SRCH_STAT_CD, old.APPL_USR_SRCH_REC_EFF_DT, NOW(), old.APPL_USR_SRCH_RSLT_LOC, old.APPL_USR_SRCH_PCT_CMPLT, old.APPL_USR_SRCH_RNG_RSLTS, 
            old.APPL_USR_SRCH_QRY, old.APPL_USR_SRCH_SRC, old.APPL_USR_SRCH_ST_DT, old.APPL_USR_SRCH_END_DT, old.APPL_USR_SRCH_ST_INDX, old.APPL_USR_SRCH_NUM_RSLTS, old.APPL_USR_SRCH_MTHD, old.APPL_USR_SRCH_LN_ID,
            old.APPL_USR_SRCH_CURR_ST_DT, old.APPL_USR_SRCH_CURR_END_DT, old.APPL_USR_SRCH_ERR_MSG, old.APPL_USR_SRCH_RETRY_CNT, old.APPL_USR_SRCH_CREATE_DT, old.APPL_USR_SRCH_QUEUE_POS,
            old.APPL_USR_SRCH_FILE_SIZE, old.APPL_USR_SRCH_FILE_SIZE_CHECK_DT, old.APPL_USR_SRCH_READY_TO_DWNLD, old.ON_HOLD, old.EMAILED);
END$$


DELIMITER ;

SET SQL_MODE=@OLD_SQL_MODE;
SET FOREIGN_KEY_CHECKS=@OLD_FOREIGN_KEY_CHECKS;
SET UNIQUE_CHECKS=@OLD_UNIQUE_CHECKS;
